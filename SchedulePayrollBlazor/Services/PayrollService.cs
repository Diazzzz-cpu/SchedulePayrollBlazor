using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using SchedulePayrollBlazor.Data;
using SchedulePayrollBlazor.Data.Models;
using SchedulePayrollBlazor.Services.Models;
using SchedulePayrollBlazor.Utilities;

namespace SchedulePayrollBlazor.Services;

public class PayrollService : IPayrollService
{
    private const string BonusType = "Bonus";
    private const string DeductionType = "Deduction";
    private const string LateSource = "Attendance-Late";
    private const string UndertimeSource = "Attendance-Undertime";
    private const string OvertimeSource = "Attendance-Overtime";
    private const string AbsenceSource = "Attendance-Absence";

    private readonly AppDbContext _db;
    private readonly IAttendanceService _attendanceService;
    private readonly IAttendanceSettingsService _attendanceSettingsService;

    public PayrollService(AppDbContext db, IAttendanceService attendanceService, IAttendanceSettingsService attendanceSettingsService)
    {
        _db = db;
        _attendanceService = attendanceService;
        _attendanceSettingsService = attendanceSettingsService;
    }

    public Task<EmployeeCompensation?> GetCompensationForEmployeeAsync(int employeeId)
    {
        return _db.EmployeeCompensations
            .Include(ec => ec.Employee)
            .FirstOrDefaultAsync(ec => ec.EmployeeId == employeeId);
    }

    public async Task UpsertCompensationAsync(EmployeeCompensation compensation)
    {
        ArgumentNullException.ThrowIfNull(compensation);

        var existing = await _db.EmployeeCompensations
            .FirstOrDefaultAsync(ec => ec.EmployeeId == compensation.EmployeeId);

        if (existing is null)
        {
            _db.EmployeeCompensations.Add(compensation);
        }
        else
        {
            existing.IsHourly = compensation.IsHourly;
            existing.HourlyRate = compensation.HourlyRate;
            existing.FixedMonthlySalary = compensation.FixedMonthlySalary;
        }

        await _db.SaveChangesAsync();
    }

    public async Task<PayrollPeriod> CreatePayrollPeriodAsync(string name, DateTime start, DateTime end)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("Payroll period name is required.", nameof(name));
        }

        if (start > end)
        {
            throw new ArgumentException("Start date cannot be later than end date.", nameof(start));
        }

        var period = new PayrollPeriod
        {
            Name = name.Trim(),
            StartDate = start,
            EndDate = end,
            CreatedAt = DateTime.UtcNow
        };

        _db.PayrollPeriods.Add(period);
        await _db.SaveChangesAsync();

        return period;
    }

    public async Task<List<PayrollEntry>> GeneratePayrollForPeriodAsync(int payrollPeriodId)
    {
        var period = await _db.PayrollPeriods
            .FirstOrDefaultAsync(pp => pp.Id == payrollPeriodId)
            ?? throw new InvalidOperationException("Unable to locate payroll period.");

        var periodStartDate = period.StartDate.Date;
        var periodEndExclusive = period.EndDate.Date.AddDays(1);

        var relevantLogsEmployeeIds = await _db.TimeLogs
            .Where(t => t.ClockIn >= periodStartDate && t.ClockIn < periodEndExclusive)
            .Select(t => t.EmployeeId)
            .Distinct()
            .ToListAsync();

        var relevantShifts = await _db.Shifts
            .Where(s => s.Start < periodEndExclusive && s.End > period.StartDate)
            .ToListAsync();

        var shiftsByEmployee = relevantShifts
            .GroupBy(s => s.EmployeeId)
            .ToDictionary(group => group.Key, group => group.ToList());

        var employeesWithActivity = new HashSet<int>(shiftsByEmployee.Keys);
        foreach (var employeeId in relevantLogsEmployeeIds)
        {
            employeesWithActivity.Add(employeeId);
        }

        var employees = await _db.Employees
            .Include(e => e.User)
            .Include(e => e.Compensation)
            .Where(e => employeesWithActivity.Contains(e.EmployeeId))
            .ToListAsync();

        var existingEntries = await _db.PayrollEntries
            .Include(pe => pe.Adjustments)
            .Where(pe => pe.PayrollPeriodId == payrollPeriodId)
            .ToListAsync();

        var existingAutoAdjustments = existingEntries
            .SelectMany(pe => pe.Adjustments?.Where(a => a.IsAutoGenerated) ?? Enumerable.Empty<PayrollAdjustment>())
            .ToList();

        if (existingAutoAdjustments.Count > 0)
        {
            _db.PayrollAdjustments.RemoveRange(existingAutoAdjustments);
        }

        foreach (var entry in existingEntries)
        {
            entry.Adjustments = entry.Adjustments
                ?.Where(a => !a.IsAutoGenerated)
                .ToList() ?? new List<PayrollAdjustment>();
        }

        var settings = await _attendanceSettingsService.GetOrCreateAsync();

        var entriesWithoutShifts = existingEntries
            .Where(pe => !employeesWithActivity.Contains(pe.EmployeeId))
            .ToList();

        if (entriesWithoutShifts.Count > 0)
        {
            _db.PayrollEntries.RemoveRange(entriesWithoutShifts);
        }

        foreach (var employee in employees)
        {
            var employeeId = employee.EmployeeId;

            var existingEntry = existingEntries.FirstOrDefault(pe => pe.EmployeeId == employeeId);

            var attendance = await _attendanceService.GetAttendanceForEmployeeAsync(
                employeeId,
                DateOnly.FromDateTime(period.StartDate),
                DateOnly.FromDateTime(period.EndDate));

            var attendanceSummary = SummarizeAttendance(attendance);
            var totalHours = Math.Round((decimal)attendanceSummary.TotalWorkedHours, 2, MidpointRounding.AwayFromZero);

            if (totalHours <= 0 && attendanceSummary.TotalAbsentDays == 0 && attendanceSummary.TotalOvertimeMinutes == 0 && attendanceSummary.TotalLateMinutes == 0 && attendanceSummary.TotalUndertimeMinutes == 0)
            {
                continue;
            }

            var basePay = CalculateBasePay(employee.Compensation, totalHours, includeFixedComponent: false);

            var entry = existingEntry;

            if (entry is null)
            {
                entry = new PayrollEntry
                {
                    PayrollPeriodId = payrollPeriodId,
                    EmployeeId = employeeId,
                    TotalHoursWorked = totalHours,
                    BasePay = basePay,
                    TotalDeductions = 0m,
                    TotalBonuses = 0m,
                    NetPay = basePay,
                    CalculatedAt = DateTime.UtcNow
                };

                _db.PayrollEntries.Add(entry);
                existingEntries.Add(entry);
            }
            else
            {
                entry.TotalHoursWorked = totalHours;
                entry.BasePay = basePay;
                entry.CalculatedAt = DateTime.UtcNow;
            }

            await ApplyAttendanceAdjustmentsAsync(entry, employee, attendance, settings);
            RecalculateEntryTotals(entry);
        }

        await _db.SaveChangesAsync();

        return await _db.PayrollEntries
            .Include(pe => pe.Employee)
                .ThenInclude(e => e.User)
            .Include(pe => pe.Employee)
                .ThenInclude(e => e.Compensation)
            .Include(pe => pe.PayrollPeriod)
            .Include(pe => pe.Adjustments)
            .Where(pe => pe.PayrollPeriodId == payrollPeriodId)
            .OrderBy(pe => pe.Employee == null ? string.Empty : pe.Employee.FullName)
            .ToListAsync();
    }

    public async Task<List<PayrollEntry>> ApplyFixedPayAsync(int payrollPeriodId, bool applyToFixed, bool applyToHybrid)
    {
        var entries = await _db.PayrollEntries
            .Include(pe => pe.Employee)
                .ThenInclude(e => e.Compensation)
            .Include(pe => pe.Adjustments)
            .Where(pe => pe.PayrollPeriodId == payrollPeriodId)
            .ToListAsync();

        foreach (var entry in entries)
        {
            var structure = PayStructureHelper.Determine(entry.Employee?.Compensation);

            if (structure == PayStructureType.Fixed && applyToFixed)
            {
                entry.BasePay = CalculateBasePay(entry.Employee?.Compensation, entry.TotalHoursWorked, includeFixedComponent: true);
                RecalculateEntryTotals(entry);
            }
            else if (structure == PayStructureType.Hybrid && applyToHybrid)
            {
                entry.BasePay = CalculateBasePay(entry.Employee?.Compensation, entry.TotalHoursWorked, includeFixedComponent: true);
                RecalculateEntryTotals(entry);
            }
        }

        await _db.SaveChangesAsync();

        return await GetPayrollEntriesForPeriodAsync(payrollPeriodId);
    }

    public Task<PayrollEntry?> GetPayrollEntryAsync(int payrollEntryId)
    {
        return _db.PayrollEntries
            .Include(pe => pe.Employee)
                .ThenInclude(e => e.User)
            .Include(pe => pe.Employee)
                .ThenInclude(e => e.Compensation)
            .Include(pe => pe.PayrollPeriod)
            .Include(pe => pe.Adjustments)
            .FirstOrDefaultAsync(pe => pe.Id == payrollEntryId);
    }

    public Task<List<PayrollEntry>> GetPayrollEntriesForPeriodAsync(int payrollPeriodId)
    {
        return _db.PayrollEntries
            .Include(pe => pe.Employee)
                .ThenInclude(e => e.User)
            .Include(pe => pe.Employee)
                .ThenInclude(e => e.Compensation)
            .Include(pe => pe.PayrollPeriod)
            .Include(pe => pe.Adjustments)
            .Where(pe => pe.PayrollPeriodId == payrollPeriodId)
            .OrderBy(pe => pe.Employee == null ? string.Empty : pe.Employee.FullName)
            .ToListAsync();
    }

    public async Task AddAdjustmentAsync(int payrollEntryId, string type, string label, decimal amount)
    {
        if (string.IsNullOrWhiteSpace(type))
        {
            throw new ArgumentException("Adjustment type is required.", nameof(type));
        }

        if (string.IsNullOrWhiteSpace(label))
        {
            throw new ArgumentException("Adjustment label is required.", nameof(label));
        }

        if (amount <= 0)
        {
            throw new ArgumentException("Adjustment amount must be greater than zero.", nameof(amount));
        }

        var entry = await _db.PayrollEntries
            .Include(pe => pe.Adjustments)
            .FirstOrDefaultAsync(pe => pe.Id == payrollEntryId)
            ?? throw new InvalidOperationException("Unable to find payroll entry for adjustment.");

        var normalizedType = NormalizeAdjustmentType(type);

        entry.Adjustments.Add(new PayrollAdjustment
        {
            PayrollEntryId = payrollEntryId,
            Type = normalizedType,
            Label = label.Trim(),
            Amount = Math.Round(amount, 2, MidpointRounding.AwayFromZero)
        });

        RecalculateEntryTotals(entry);

        await _db.SaveChangesAsync();
    }

    public async Task RemoveAdjustmentAsync(int adjustmentId)
    {
        var adjustment = await _db.PayrollAdjustments
            .FirstOrDefaultAsync(pa => pa.Id == adjustmentId)
            ?? throw new InvalidOperationException("Unable to find adjustment to remove.");

        var entry = await _db.PayrollEntries
            .Include(pe => pe.Adjustments)
            .FirstOrDefaultAsync(pe => pe.Id == adjustment.PayrollEntryId)
            ?? throw new InvalidOperationException("Unable to find payroll entry for adjustment removal.");

        _db.PayrollAdjustments.Remove(adjustment);

        RecalculateEntryTotals(entry);

        await _db.SaveChangesAsync();
    }

    private async Task ApplyAttendanceAdjustmentsAsync(
        PayrollEntry entry,
        Employee employee,
        IEnumerable<DailyAttendanceDto> attendance,
        AttendancePenaltySettings settings)
    {
        entry.Adjustments ??= new List<PayrollAdjustment>();

        var hourlyRate = CalculateHourlyRate(employee.Compensation);

        foreach (var day in attendance)
        {
            if (day.IsLate && day.LateMinutes > 0 && settings.LatePenaltyPerMinute > 0)
            {
                var amount = day.LateMinutes * settings.LatePenaltyPerMinute;
                entry.Adjustments.Add(CreateAutoAdjustment(
                    entry.Id,
                    DeductionType,
                    LateSource,
                    $"Late penalty {day.Date:yyyy-MM-dd} ({day.LateMinutes} mins)",
                    amount));
            }

            if (day.IsUndertime && day.UndertimeMinutes > 0 && settings.UndertimePenaltyPerMinute > 0)
            {
                var amount = day.UndertimeMinutes * settings.UndertimePenaltyPerMinute;
                entry.Adjustments.Add(CreateAutoAdjustment(
                    entry.Id,
                    DeductionType,
                    UndertimeSource,
                    $"Undertime {day.Date:yyyy-MM-dd} ({day.UndertimeMinutes} mins)",
                    amount));
            }

            if (day.IsAbsent && day.ScheduledHours > 0 && settings.AbsenceFullDayMultiplier > 0)
            {
                // Use an approximate hourly rate when only monthly salary is available.
                if (hourlyRate > 0)
                {
                    var amount = settings.AbsenceFullDayMultiplier * hourlyRate * day.ScheduledHours;
                    entry.Adjustments.Add(CreateAutoAdjustment(
                        entry.Id,
                        DeductionType,
                        AbsenceSource,
                        $"Absence {day.Date:yyyy-MM-dd} ({day.ScheduledHours:N2} hrs)",
                        amount));
                }
            }

            if (day.IsOvertime && day.OvertimeMinutes > 0 && settings.OvertimeBonusPerMinute > 0)
            {
                var amount = day.OvertimeMinutes * settings.OvertimeBonusPerMinute;
                entry.Adjustments.Add(CreateAutoAdjustment(
                    entry.Id,
                    BonusType,
                    OvertimeSource,
                    $"Overtime bonus {day.Date:yyyy-MM-dd} ({day.OvertimeMinutes} mins)",
                    amount));
            }
        }
    }

    private static PayrollAdjustment CreateAutoAdjustment(
        int payrollEntryId,
        string type,
        string source,
        string label,
        decimal amount)
    {
        return new PayrollAdjustment
        {
            PayrollEntryId = payrollEntryId,
            Type = type,
            Label = label,
            Amount = Math.Round(amount, 2, MidpointRounding.AwayFromZero),
            Source = source,
            IsAutoGenerated = true
        };
    }

    private static decimal CalculateHourlyRate(EmployeeCompensation? compensation)
    {
        if (compensation is null)
        {
            return 0m;
        }

        if (compensation.HourlyRate.HasValue && compensation.HourlyRate.Value > 0)
        {
            return compensation.HourlyRate.Value;
        }

        if (compensation.FixedMonthlySalary.HasValue && compensation.FixedMonthlySalary.Value > 0)
        {
            // Assumes a standard 160-hour working month when an hourly rate is not provided explicitly.
            return Math.Round(compensation.FixedMonthlySalary.Value / 160m, 2, MidpointRounding.AwayFromZero);
        }

        return 0m;
    }

    private static decimal CalculateBasePay(EmployeeCompensation? compensation, decimal totalHours, bool includeFixedComponent)
    {
        var structure = PayStructureHelper.Determine(compensation);
        var hourlyRate = compensation?.HourlyRate ?? 0m;
        var fixedSalary = includeFixedComponent ? compensation?.FixedMonthlySalary ?? 0m : 0m;

        var basePay = structure switch
        {
            PayStructureType.Hourly => totalHours * hourlyRate,
            PayStructureType.Hybrid => (totalHours * hourlyRate) + fixedSalary,
            PayStructureType.Fixed => fixedSalary,
            _ => totalHours * hourlyRate
        };

        return Math.Round(basePay, 2, MidpointRounding.AwayFromZero);
    }

    private static AttendanceSummary SummarizeAttendance(IEnumerable<DailyAttendanceDto> attendance)
    {
        var workedHours = attendance
            .Where(d => d.HasLogs)
            .Sum(d => d.TotalDuration.TotalHours);

        var lateMinutes = attendance
            .Where(d => d.HasLogs && d.IsLate && d.LateMinutes > 0)
            .Sum(d => d.LateMinutes);

        var undertimeMinutes = attendance
            .Where(d => d.HasLogs && d.IsUndertime && d.UndertimeMinutes > 0)
            .Sum(d => d.UndertimeMinutes);

        var overtimeMinutes = attendance
            .Where(d => d.HasLogs && d.IsOvertime && d.OvertimeMinutes > 0)
            .Sum(d => d.OvertimeMinutes);

        var absentDays = attendance.Count(d => d.IsAbsent);
        var absentScheduledHours = attendance
            .Where(d => d.IsAbsent && d.ScheduledHours > 0)
            .Sum(d => d.ScheduledHours);

        return new AttendanceSummary
        {
            TotalWorkedHours = workedHours,
            TotalLateMinutes = lateMinutes,
            TotalUndertimeMinutes = undertimeMinutes,
            TotalOvertimeMinutes = overtimeMinutes,
            TotalAbsentDays = absentDays,
            TotalScheduledHoursForAbsences = absentScheduledHours
        };
    }

    private static string NormalizeAdjustmentType(string type)
    {
        return string.Equals(type, DeductionType, StringComparison.OrdinalIgnoreCase)
            ? DeductionType
            : BonusType;
    }

    private static decimal SumAdjustments(IEnumerable<PayrollAdjustment> adjustments, string type)
    {
        return adjustments
            .Where(a => string.Equals(a.Type, type, StringComparison.OrdinalIgnoreCase))
            .Sum(a => a.Amount);
    }

    private static void RecalculateEntryTotals(PayrollEntry entry)
    {
        var adjustments = entry.Adjustments ?? new List<PayrollAdjustment>();

        entry.TotalDeductions = Math.Round(SumAdjustments(adjustments, DeductionType), 2, MidpointRounding.AwayFromZero);
        entry.TotalBonuses = Math.Round(SumAdjustments(adjustments, BonusType), 2, MidpointRounding.AwayFromZero);

        entry.NetPay = Math.Round(entry.BasePay - entry.TotalDeductions + entry.TotalBonuses, 2, MidpointRounding.AwayFromZero);
        entry.CalculatedAt = DateTime.UtcNow;
    }
}

internal sealed class AttendanceSummary
{
    public double TotalWorkedHours { get; init; }

    public int TotalLateMinutes { get; init; }

    public int TotalUndertimeMinutes { get; init; }

    public int TotalOvertimeMinutes { get; init; }

    public int TotalAbsentDays { get; init; }

    public decimal TotalScheduledHoursForAbsences { get; init; }
}
